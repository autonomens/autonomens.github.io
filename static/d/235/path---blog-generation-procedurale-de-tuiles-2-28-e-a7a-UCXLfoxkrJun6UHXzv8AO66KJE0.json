{"data":{"markdownRemark":{"id":"11175456-5f3d-54a4-9813-01d68a92fb39","html":"<p>Cette carte de Toulouse a été créée à partir de données provenant de OpenStreetMap ; la zone affichée se situe à Toulouse et ses environs.</p>\n<h2>La donne</h2>\n<p>En m'imaginant comment je dessinerais moi-même cette carte, à l'échelle des quartiers, je me suis dit que j'aurais travaillé en différentes étapes. Tout d'abord une ébauche rapide au crayon des bâtiments, avec des formes plutôt arrondies (utilisant le line-smooth).</p>\n<p>Puis à l'aide d'une règle j'aurais tracé les contours des maisons. Seulement une ville comme Toulouse en contient beaucoup... (environ 450 000 habitants). J'aurais donc sacrifié un peu de précision pour tout tracer.</p>\n<p>Et que fait-on quand on est pressé en dessin ? On déborde, on dépasse ! Mais cette notion n'est pas connue des moteurs de rendu SIG. Il m'a donc fallu modifier cette donnée à la source, dans PostGIS.\nLes données</p>\n<p>Téléchargés depuis OpenStreetMap, les polygones (tous confondus : bâtiments, zones administratives, parcs, fleuves...) se trouvent dans la table planet<em>osm</em>polygon. Les bâtiments sont identifiables par l'attribut 'building'='yes'. Il y en a 342 790 en tout.</p>\n<p>Je vais suivre deux étapes pour parvenir à mon but :</p>\n<ul>\n<li>découper les polygones en linestring</li>\n<li>agrandir ces nouvelles lignes</li>\n</ul>\n<h2>Découper les polygones</h2>\n<p>Techniquement, si je veux pouvoir prolonger chaque trait de manière à ce qu'il déborde, il me d'abord découper les polygones en lignes distinctes, que je pourrai ensuite manipuler comme je le veux.</p>\n<p>En cherchant sur le web, je trouve un article qui me donne la solution : \"<a href=\"https://stackoverflow.com/questions/7595635/how-to-convert-polygon-data-into-line-segments-using-postgis\">How to convert polygon data into line segments using PostGIS</a>\".</p>\n<p>Je crée donc une nouvelle table (que je nomme poly2line) :</p>\n<pre><code class=\"language-sql\">CREATE TABLE poly2line (\n id serial NOT NULL,\n way geometry(LineString,900913),\n long_way geometry(LineString,900913),\n type text,\n CONSTRAINT poly2line_pkey PRIMARY KEY (id)\n)\n</code></pre>\n<p>Puis j'applique ce script qui va s'intéresser à chaque segment rectiligne composant le polygone, pour créer de nouvelles lignes distinctes :</p>\n<pre><code>INSERT INTO poly2line (way)\nSELECT ST_MakeLine(sp,ep)\nFROM\n-- extract the endpoints for every 2-point line segment for each linestring\n(SELECT\n ST_PointN(geom, generate_series(1, ST_NPoints(geom)-1)) as sp,\n ST_PointN(geom, generate_series(2, ST_NPoints(geom) )) as ep\n FROM\n -- extract the individual linestrings\n (SELECT (ST_Dump(ST_Boundary(way))).geom\n FROM planet_osm_polygon WHERE building IS NOT NULL\n ) AS linestrings\n) AS segments\n</code></pre>\n<p>Ces lignes, toujours fidèles au tracé original, sont stockées dans le champ 'way'. J'obtiens à partir des 342 790 bâtiments 2 440 585 lignes.</p>\n<p>Je ne suis pas plus avancé pour l'instant : si j'affiche ces éléments dans TileMill, ils ont exactement le même aspect que les polygones d'origine.</p>\n<h2>Agrandir les lignes</h2>\n<p>Il me faut maintenant trouver une méthode pour agrandir ces lignes. Là encore, en cherchant sur internet, je trouve une piste intéressante : \"<a href=\"https://gis.stackexchange.com/questions/33055/extrapolating-a-line-in-postgis\">postgis, extrapolate a line</a>\".</p>\n<p>Je crée une fonction afin d'appliquer cette méthode à toutes les lignes :</p>\n<pre><code>CREATE OR REPLACE FUNCTION agrandir_ligne(ligne geometry)\nRETURNS geometry AS $$\nDECLARE A geometry;\nDECLARE B geometry;\nDECLARE azimuthA double precision;\nDECLARE azimuthB double precision;\nDECLARE length double precision;\nDECLARE newlengthA double precision;\nDECLARE newlengthB double precision;\nDECLARE newA geometry;\nDECLARE newB geometry;\nBEGIN\n\n-- crée des points A et B aux extrémités de la ligne\nA := ST_STARTPOINT(ligne);\nB := ST_ENDPOINT(ligne);\n\n-- récupère 2 directions : de B vers A, puis de A vers B\nazimuthA := ST_AZIMUTH(B,A);\nazimuthB := ST_AZIMUTH(A,B);\n\n-- récupère la longueur entre les points A et B et définition d'une nouvelle longueur à ajouter\nlength := ST_DISTANCE(A,B);\nnewlengthA := length/5;\nnewlengthB := length/5;\n\n-- crée un nouveau point A et un nouveau point B dans la direction déterminée et dans un rapport de 1/x de la longueur d'origine\nnewA := ST_TRANSLATE(A, sin(azimuthA) * newlengthA, cos(azimuthA) * newlengthA);\nnewB := ST_TRANSLATE(B, sin(azimuthB) * newlengthB, cos(azimuthB) * newlengthB);\n\n-- crée une ligne entre ces 2 nouveaux points\nRETURN ST_Makeline(newA,newB);\n\nEND;\n$$ LANGUAGE plpgsql;\n</code></pre>\n<p>Ma première tentative était trop régulière, car je n'avais pas inclus d'élément aléatoire : toutes les lignes dépassaient de 1/5 de leur longueur d'origine. J'ai donc ajouté dans la déclaration des variables newlengthA et newlengthB une valeur aléatoire : random(), qui génère un nombre de 0.0 à 1.0.</p>\n<pre><code>newlengthA := (length/5)*random();\nnewlengthB := (length/5)*random();\n</code></pre>\n<p>Les lignes stockées dans le champ 'way' sont ainsi traitées et enregistrées dans le champ 'long_way', qui sera appelé dans une couche sous TileMill.</p>\n<p>Après <a href=\"https://makina-corpus.com/blog/metier/2014/dessiner-une-ville-a-la-main-les-batiments\">quelques paramétrages de rendu sous TileMill</a> nous arrivons donc à ce résultat :</p>\n<p><img src=\"https://makina-corpus.com/blog/metier/images/dessin-toulouse-decoupage-des-batiments\"></p>","frontmatter":{"date":"February 04, 2017","title":"Dessiner une ville à la main avec TileMill (2 - Découper 340 000 polygones)","description":"Comme nous l'avons vu dans un précédent article, la création d'une carte urbaine reproduisant un style crayonné repose sur la superposition de plusieurs effets - code sous TileMill, textures sous Gimp... Nous allons nous intéresser aujourd'hui à une intervention plus en amont - le découpage des polygones de bâtiments directement dans la base de données PostGIS.","tags":["carto","tilemill"]}}},"pageContext":{"id":"11175456-5f3d-54a4-9813-01d68a92fb39"}}